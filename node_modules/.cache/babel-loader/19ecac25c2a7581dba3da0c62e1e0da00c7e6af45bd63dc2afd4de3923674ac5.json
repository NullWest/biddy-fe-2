{"ast":null,"code":"var _jsxFileName = \"/Users/davebinary/code/biddy-ts/src/stateMachines/queryMachine.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState } from 'react';\n\n/*\n  Eventually switch this to a DB-driven system \n  for state based on whether User ID is known.\n*/\n\n// Define placehoder \nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst STATE_ONE = 'STATE_ONE';\nconst STATE_TWO = 'STATE_TWO';\n// Create Context with an initial value of undefined\nconst QueryMachineContext = /*#__PURE__*/createContext(undefined);\n\n// Define the provider component\nexport const QueryMachine = ({\n  children\n}) => {\n  _s();\n  const [state, setState] = useState(STATE_ONE);\n  const [conversationsData, setConversationsData] = useState([]);\n  const transitionToStateTwo = () => {\n    setState(STATE_TWO);\n  };\n  const transitionToStateOne = () => {\n    setState(STATE_ONE);\n  };\n  const addConversationsData = response => {\n    setConversationsData(prevData => [...prevData, response]);\n  };\n  const value = {\n    state,\n    conversationsData,\n    addConversationsData,\n    transitionToStateTwo,\n    transitionToStateOne\n  };\n  return /*#__PURE__*/_jsxDEV(QueryMachineContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 56,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the QueryMachineContext\n_s(QueryMachine, \"M4RK6MdVIYF4LvZMTpsf/gA50Xc=\");\n_c = QueryMachine;\nexport const useQueryMachine = () => {\n  _s2();\n  const context = useContext(QueryMachineContext);\n  if (!context) {\n    throw new Error('useQueryMachine must be used within a QueryMachine');\n  }\n  return context;\n};\n_s2(useQueryMachine, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"QueryMachine\");","map":{"version":3,"names":["React","createContext","useContext","useState","jsxDEV","_jsxDEV","STATE_ONE","STATE_TWO","QueryMachineContext","undefined","QueryMachine","children","_s","state","setState","conversationsData","setConversationsData","transitionToStateTwo","transitionToStateOne","addConversationsData","response","prevData","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useQueryMachine","_s2","context","Error","$RefreshReg$"],"sources":["/Users/davebinary/code/biddy-ts/src/stateMachines/queryMachine.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, ReactNode } from 'react';\n\n/*\n  Eventually switch this to a DB-driven system \n  for state based on whether User ID is known.\n*/\n\n// Define placehoder \nconst STATE_ONE = 'STATE_ONE';\nconst STATE_TWO = 'STATE_TWO';\n\ninterface QueryMachineContextType {\n  state: string;\n  conversationsData: MessageStructure[]; // Use correct type for the conversations\n  addConversationsData: (response: MessageStructure) => void; \n  transitionToStateTwo: () => void;\n  transitionToStateOne: () => void;\n}\n\ninterface MessageStructure {\n  userName: string,\n  message: string,\n  timestamp: number,\n  isUser: boolean,\n}\n\n// Create Context with an initial value of undefined\nconst QueryMachineContext = createContext<QueryMachineContextType | undefined>(undefined);\n\n// Define the provider component\nexport const QueryMachine = ({ children }: { children: ReactNode }) => {\n  const [state, setState] = useState(STATE_ONE);\n  const [conversationsData, setConversationsData] = useState<MessageStructure[]>([]);\n\n  const transitionToStateTwo = () => {\n    setState(STATE_TWO);\n  };\n\n  const transitionToStateOne = () => {\n    setState(STATE_ONE);\n  };\n\n  const addConversationsData = (response: MessageStructure) => {\n    setConversationsData((prevData) => [...prevData, response]);\n  };\n\n  const value = {\n    state,\n    conversationsData,\n    addConversationsData,\n    transitionToStateTwo,\n    transitionToStateOne,\n  };\n\n  return (\n    <QueryMachineContext.Provider value={value}>\n      {children}\n    </QueryMachineContext.Provider>\n  );\n};\n\n// Custom hook to use the QueryMachineContext\nexport const useQueryMachine = () => {\n  const context = useContext(QueryMachineContext);\n  if (!context) {\n    throw new Error('useQueryMachine must be used within a QueryMachine');\n  }\n  return context;\n};"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,QAAmB,OAAO;;AAE7E;AACA;AACA;AACA;;AAEA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,SAAS,GAAG,WAAW;AAC7B,MAAMC,SAAS,GAAG,WAAW;AAiB7B;AACA,MAAMC,mBAAmB,gBAAGP,aAAa,CAAsCQ,SAAS,CAAC;;AAEzF;AACA,OAAO,MAAMC,YAAY,GAAGA,CAAC;EAAEC;AAAkC,CAAC,KAAK;EAAAC,EAAA;EACrE,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGX,QAAQ,CAACG,SAAS,CAAC;EAC7C,MAAM,CAACS,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGb,QAAQ,CAAqB,EAAE,CAAC;EAElF,MAAMc,oBAAoB,GAAGA,CAAA,KAAM;IACjCH,QAAQ,CAACP,SAAS,CAAC;EACrB,CAAC;EAED,MAAMW,oBAAoB,GAAGA,CAAA,KAAM;IACjCJ,QAAQ,CAACR,SAAS,CAAC;EACrB,CAAC;EAED,MAAMa,oBAAoB,GAAIC,QAA0B,IAAK;IAC3DJ,oBAAoB,CAAEK,QAAQ,IAAK,CAAC,GAAGA,QAAQ,EAAED,QAAQ,CAAC,CAAC;EAC7D,CAAC;EAED,MAAME,KAAK,GAAG;IACZT,KAAK;IACLE,iBAAiB;IACjBI,oBAAoB;IACpBF,oBAAoB;IACpBC;EACF,CAAC;EAED,oBACEb,OAAA,CAACG,mBAAmB,CAACe,QAAQ;IAACD,KAAK,EAAEA,KAAM;IAAAX,QAAA,EACxCA;EAAQ;IAAAa,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACmB,CAAC;AAEnC,CAAC;;AAED;AAAAf,EAAA,CA/BaF,YAAY;AAAAkB,EAAA,GAAZlB,YAAY;AAgCzB,OAAO,MAAMmB,eAAe,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACnC,MAAMC,OAAO,GAAG7B,UAAU,CAACM,mBAAmB,CAAC;EAC/C,IAAI,CAACuB,OAAO,EAAE;IACZ,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;EACvE;EACA,OAAOD,OAAO;AAChB,CAAC;AAACD,GAAA,CANWD,eAAe;AAAA,IAAAD,EAAA;AAAAK,YAAA,CAAAL,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}